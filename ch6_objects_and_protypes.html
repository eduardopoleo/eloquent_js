<script type="text/javascript">
	//We can use existing objects as 'molds' for other objects

	var protoRabbit = {
		speak: function(line){
			console.log("the " + this.type + " Rabbit says " + line)
		}
	}
	var killerRabbit = Object.create(protoRabbit)
	killerRabbit.type = "killer"
	killerRabbit.speak("Yahhhhh")


	// Or we can use formal constructors which are basically function:
	function Rabbit(type){
		this.type = type
	}

	var killerRabbit = new Rabbit("killer")

	console.log(killerRabbit.type)

	// The constructors get a prototype that serve as a mold

	 Rabbit.prototype.color = function(input){} 
	 Rabbit.prototype.size = function(input){} 
	 Rabbit.prototype.weight = function(input){} 
	 Rabbit.prototype.noise = "Yikes"

	 // The constuctor provides the new keyword
	 blizzardRabbit = new Rabbit("blizzar")

	 //We can use the prototype to give a provide a general property to all the objects 

	 Rabbit.prototype.theeth = "big and nasty"
	 //now all rabbits will have big and nasty theeth

	 //This could cause interferance 
	 Object.prototype.nonsense = 'hi'
		
	for (var prop in killerRabbit)
		console.log(prop)

	//will display the nonsense property.

	console.log("toString" in killerRabbit) 
	//This outputs true because it is a property but no enumerable

	//Enumerables are those properties that we can explicity set through 
	Rabbit.prototype.color = "red"

	//"toString" is not one of those. To create one of those we have to

	Object.defineProperty(Object.prototype, "hiddenNonsense", {enumerable: false, value: "hi"});

	//Nonsense wont show up if we use for (var name in killerRabbit)

	//and we only want to see the objects own properties we can use
	console.log(killerRabbit.hasOwnProperty("toString"));

</script>